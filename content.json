{"meta":{"title":"zdszx's blog","subtitle":"Hello","description":null,"author":null,"url":"http://zdszx.github.io","root":"/"},"pages":[{"title":"404","date":"2021-07-03T08:13:26.000Z","updated":"2021-07-06T08:05:21.000Z","comments":true,"path":"404/index.html","permalink":"http://zdszx.github.io/404/index.html","excerpt":"","text":""},{"title":"关于我","date":"2021-07-03T09:27:49.000Z","updated":"2021-07-06T07:31:43.000Z","comments":true,"path":"about/index.html","permalink":"http://zdszx.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-07-03T08:12:23.000Z","updated":"2021-07-03T08:12:23.000Z","comments":true,"path":"categories/index.html","permalink":"http://zdszx.github.io/categories/index.html","excerpt":"","text":""},{"title":"contact","date":"2021-07-03T08:12:59.000Z","updated":"2021-07-03T08:12:59.000Z","comments":true,"path":"contact/index.html","permalink":"http://zdszx.github.io/contact/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-07-03T08:12:44.000Z","updated":"2021-07-03T08:12:44.000Z","comments":true,"path":"tags/index.html","permalink":"http://zdszx.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Python3","slug":"RenderPipe","date":"2021-07-29T02:00:58.000Z","updated":"2021-08-01T08:14:20.205Z","comments":true,"path":"2021/07/29/RenderPipe/","link":"","permalink":"http://zdszx.github.io/2021/07/29/RenderPipe/","excerpt":"","text":"渲染流水线（ rendering pipeline）如果给出一台具有确定位置和朝向的虚拟摄像机（ virtual camera）以及某个3D场景的几何描述，那么渲染流水线则是以此虚拟摄像机为视角进行观察，并据此生成给定3D场景2D图像的一整套处理步骤。 渲染流水线可以划分为输入装配（ Input Assembly，IA）阶段、顶点着色器（ Vertex Shader，vs）阶段、曲面细分（ tessellation）阶段、几何着色器（ Geometry Shader，Gs）阶段、裁剪阶段、光栅化（ Rasterization Shader，RS）阶段、像素着色器（ Pixel shader，PS）阶段以及输出合并（ Output Merge OM）等重要阶段 1.输入装配器阶段输入装配器（ Input Assembler，IA）阶段会从显存中读取几何数据（顶点和索引， vertex and index），再将它们装配为几何图元（ geometric primitive，亦译作几何基元，如三角形和践条这种构成图形的基本元素）。简单来说，是通过索引来定义如何将顶点装配在一起，从而构成图元的方法。 在 Direct3D中，我们要通过一种名为顶点缓冲区（ vertex buffer）的特殊数据结构，将顶点与渲染流水线相绑定。顶点缓冲区利用连续的内存来存储一系列顶点。可是，仅凭这一点并不能说明这些顶点究竟如何组成几何图元。对此要通过指定图元拓扑（ primitive topology）来告知 Direct3D如何用顶点数据来表示几何图元。 2.顶点着色器阶段待图元被装配完毕后，其顶点就会被送入顶点着色器阶段（ vertex shader stage，简记作VS）。把顶点着色器看作一种输入与输出数据皆为单个顶点的函数。每个要被绘制的顶点都须经过顶点着色器的处理再送往后续阶段。事实上，我们可以认为在硬件中执行的是下列处理过程 for （UINT i =0， i&lt; numVertices; ++1） outputvertex[i] = VertexShader（ inputVertex[i]）; 其中的顶点着色器函数（ Vertexshader）就是我们要实现的那一部分，因为在这一阶段中对顶点的操作实际是由GPU来执行的，所以速度很快, 可以利用顶点着色器来实现许多特效，例如变换、光照和位移贴图（ displacement mapping，也译作置换贴图）。请牢记: 在顶点着色器中，不但可以访问输入的顶点数据，也能够访问纹理和其他存于显存中的数据（如变换矩阵与场景的光照信息）。 世界空间(世界矩阵) ，观察空间(观察矩阵) ， 齐次裁剪空间(透视投影矩阵) 3.曲面细分阶段曲面细分阶段（ tessellation stages）是利用镶嵌化处理技术对网格中的三角形进行细分（ subdivide），以此来增加物体表面上的三角形数量。再将这些新增的三角形偏移到适当的位置，使网格表现出更加细腻的细节。 使用曲面细分的优点有以下几方面: 1.我们能借此实现一种细节层次（ level- of-detail，LOD）机制，使离虚拟摄像机较近的三角形经镶嵌化处理得到更加丰富的细节，而对距摄像机较远的三角形不进行任何更改。通过这种方式，即可只针对用户关注度高的部分网格增添三角形，从而提升其细节效果。 2.我们在内存中仅维护简单的低模（ low-poly，低精度模型，也有译作低面多边形、低面片等）网格（低模网格是指三角形数量较少的网格，已逐渐形成一门独特画风的艺术制作手段），再根据需求为它动态地增添额外的三角形，以此节省内存资源 3.我们可以在处理动画和物理模拟之时采用简单的低模网格，而仅在渲染的过程中使用经镶嵌化处理的高模（high-poly，与低模对应）网格。 4.几何着色器阶段几何着色器（ geometry shader stage，GS）是一个可选渲染阶段，几何着色器接受的输入应当是完整的图元。例如，假设我们正在绘制三角形列表，那么向几何着色器传入的将是定义三角形的3个顶点（注意，这3个顶点在此之前已经过了顶点着色器阶段的处理）几何着色器的主要优点是可以创建或销毁几何体。比如说，我们可以利用几何着色器将输入的图元拓展为一个或多个其他图元，抑或根据某些条件而选择不输出任何图元。 顶点着色器与之相比，则不能创建顶点; 它只能接受输入的单个顶点，经处理后再将该顶点输出。几何着色器的常见拿手好戏是将一个点或一条线扩展为一个四边形。 5.裁剪完全位于视锥体（ viewing frustum，用户在3D空间中的可视范围形如平截头体）之外的几何体需要被丢弃，而处于平截头体交界以外的几何体部分也一定要接受被裁剪（clip）的操作。因此，只有在平截头体之内的物体对象才会最终保留下来。只要确定了视锥体在齐次空间内的平面方程，就可运用裁剪算法，一种比较流行的裁剪方法: Sutherland-Hodgman clipping, 其整体思路是找到平面与多边形的所有交点，并将这些顶点按顺序组织成新的裁剪多边形。 光栅化阶段光栅化阶段（ rasterization stage，RS）的主要任务是为投影主屏幕上的3D三角形计算出对应的像素颜色。 像素着色器阶段我们编写的像素着色器（ pixel shader，PS）是一种由GPU来执行的程序。它会针对每一个像素片段（ pixel fragment，亦有译作片元）进行处理（即每处理一个像素就要执行一次像素着色器），并根据顶点的插值属性作为输入来计算出对应的像素颜色。像素着色器既可以直接返回一种单一的恒定颜色，也可以实现如逐像素光照（ per-pixel lighting）反射（ reflection）以及阴影（ shadow）等更为复杂的效果。 输出合并阶段通过像素着色器生成的像素片段会被移送至渲染流水线的输出合并（ Output Merger，OM）阶段。在此阶段中，一些像素片段可能会被丢弃（例如，那些未通过深度缓冲区测试或模板缓冲区测试的像素片段）。而后，剩下的像素片段将会被写入后台缓冲区中。混合（bend，也有译作融合）操作也是在此阶段实现的，此技术可令当前处理的像素与后台缓冲区中的对应像素相融合，而不仅是对后者进行完全的覆写。一些如“透明”这样的特殊效果，也是由混合技术来实现的。","categories":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://zdszx.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"DX11 pipeline","slug":"DX11-pipeline","permalink":"http://zdszx.github.io/tags/DX11-pipeline/"}]},{"title":"Python3","slug":"Python","date":"2021-07-25T12:00:58.000Z","updated":"2021-07-30T12:58:00.626Z","comments":true,"path":"2021/07/25/Python/","link":"","permalink":"http://zdszx.github.io/2021/07/25/Python/","excerpt":"","text":"Python元类Python中的所有内容都可以定义为具有属性和方法的对象。 一个简单的类在声明时没有分配任何内存，它是在创建一个类的实例时发生的。 通过创建的对象，可以访问该类。该类仅用作模板。对象的属性本质上意味着我们可以在运行时与它进行交互，传递诸如变量之类的参数，进行存储，修改，也可以与它进行交互。 Python是一种动态编程语言，并允许在运行时创建类。与C ++等其他语言不同，后者仅允许在编译时创建类。在灵活性方面，Python优于其他静态类型的语言。 可以通过两种方法创建元类：1.类型类; 2. 自定义元类: 2.1 new （）：当用户要在类创建之前定义元组字典时使用。它返回一个类的实例，并且很容易覆盖/管理对象流 2.2 init （）：在创建对象并对其进行初始化之后调用它; Python静态方法和类方法的区别类方法和静态方法的区别在于，Python会自动绑定类方法的第一个参数，类方法的第一个参数（通常建议参数名为 cls）会自动绑定到类本身；但对于静态方法则不会自动绑定。 类方法采用装饰器@classmethod来定义 静态方法使用装饰器@staticmethod来定义一个静态方法。 py字典底层设计字典是通过散列表或说哈希表实现的 其本质是一个多对一的映射，这也就引出了下面一个概念–哈希冲突或者说哈希碰撞 常见的哈希碰撞解决方法： 1 开放寻址法（open addressing） 2 再哈希法 3 链地址法 4 公共溢出区 5 装填因子α set的底层数据结构是什么？set和dict的区别（1）dict是用来存储键值对结构的数据的，set其实也是存储的键值对，只是默认键和值是相同的。Python中的dict和set都是通过散列表来实现的。 （2）dict中的数据是无序存放的,操作的时间复杂度，插入、查找和删除都可以在O(1)的时间复杂度键的限制，只有可哈希的对象才能作为字典的键和set的值。可hash的对象即python中的不可变对象和自定义的对象。可变对象(列表、字典、集合)是不能作为dict的键和set的值的。与list相比：list的查找和删除的时间复杂度是O(n)，添加的时间复杂度是O(1)。但是dict使用hashtable内存的开销更大。为了保证较少的冲突，hashtable的装载因子，一般要小于0.75，在python中当装载因子达到2/3的时候就会自动进行扩容 list和tuple的底层数据结构是什么？python的list和tuple，均采用了顺序表的结构。Tuple不支持改变内部状态的操作。（1）顺序表：将表元素直接顺序的放在一块划分的连续存储区内，所以元素的顺序关系由存储顺序自然表示。链接表：将表元素放在通过链接构造起来的系列存储块里。两种模型各有长短。插入和删除的时间复杂度为O(n)，增加的时间复杂度为O(1)（2）在存储dict的时候，首先会根据dict的key进行hash映射到对应的表元，然后再对应的表元中开辟内存，存入数据，当如果存在不同的两个key的hash结果相同的时候，就会使用散列值的另一部分来定位散列表中的另一行。在查找指定key时，会先计算key的散列值，然后使用散列值的一部分来定位表元，如果没有找到相应的表元，则说明dict中不存在对应的key跑出KeyError异常。如果找到表元之后，会判断表元中的key是否和要查找的key相等，相等就返回对应值，如果不相等则使用其对应的散列值的其他部分来定位散列表中的其他行。 py上下文管理器设计上下文管理器，能够帮助你自动分配并且释放资源，其中最典型的应用便是 with 语句 如何去实现一个迭代器的功能？答：实现一个迭代器，只需要实现_next__方法就行了。如果实现一个可迭代对象，实现iter方法就可以了。 yield和yield from有何区别？yield是直接返回值，yield from调用子生成器进行迭代那个可迭代对象。比如yield一个列表，那么next(g）就是整个列表，而如果yield from 列表，next(g)得到的就是一个子元素 py深浅复制在修改时不想修改原对象，那么可以用深拷贝弄一个新的内存对象采用 python多继承的顺序自下而上，自左而右。","categories":[{"name":"python","slug":"python","permalink":"http://zdszx.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://zdszx.github.io/tags/python/"}]},{"title":"H.264简介","slug":"H264","date":"2021-07-03T07:04:58.000Z","updated":"2021-07-07T12:56:57.000Z","comments":true,"path":"2021/07/03/H264/","link":"","permalink":"http://zdszx.github.io/2021/07/03/H264/","excerpt":"","text":"1.H.264简介 1.1 H.264标准概述 H.264也称为高级视频编码MPEG-4 AVC或MPEG-4 Part 10。视频编码属于后处理技术，因为从摄像机采集出来的数据十分庞大，不适合网络传输和存储，故需要对视频进行编码压缩，以达到低码率、高成像质量的目的。H.264文件是视频编解码器标准文件，以其压缩效率方面的优势和足够的灵活性而广为应用，到目前为止，它是视频内容的记录，压缩和分发的最常用格式，截至2019年9月，已有91％的视频行业开发人员使用了该格式。它支持高达8K的分辨率[1]。H264标准的卓越之处在于其宏块变体，以前的标准只能单独使用块4×4、8×8和16×16切分图像作帧间帧内编码，但是H264标准能使用多种不同的块大小。除此之外目前，该标准还应用于物联网[2]。 H264视频编码标准包含的编码算法[3]： 1) 帧间帧内预测，帧间即为多参考帧的时域数据压缩，帧内即为变尺寸块的空域数据 压缩[4]； 2) 变换编码，为了减少混叠并锐化图像，将空间域的图像信号变换到变换域或频率域的正交矢量空间中，用数字滤波器产生像素的亮度分量预测值，服务于帧间运动检测与图像质量呈现 [5]； 3) 熵编码，图像声音信号均为随机信号序列，故可以利用信息论原理减少数据冗余，主要有CABAC上下文自适应二进制算术编码,CAVLC上下文自适应二进制算术编码[6]； 4) 使用一个网络抽像层（NAL），进一步封装编码后的视频码流，使得相同的视频语法 可以适用于多种网络环境中。 1.2 H.264编码原理介绍 1.2.1 H.264编码方案总览 目标：1) 获得高视频压缩比；2) 具有良好的网络亲和性。对此，使用的解决方案为: 1) VLC 视频编码层；2) NAL 网络抽象层。 H.264字节流由 NALU（NAL Unit）组成，并且每个NALU可以被分类为VCL或非VCL。 1.2.2 VLC层和NAL层关系 VLC层是对核心算法引擎，块，宏块及片语法级别的定义，它输出由MPEG Part 10定义的H.264编码完的原始数据SODB(数据比特串)。原始字节序列有效负载（RBSP）是一种语法结构，包含封装在NAL单元中的整数个字节。如图1所示，在获得SODB之后，将添加等于1的尾随比特以指示SODB的末尾，该比特称为RBSP Stop bit，此外，RBSP始终按字节对齐，并且在停止位之后添加0位以变为8位对齐[7]。 SODB_RBSP_EBSP_NALU关系 NAL层定义了片级以上的语法级别，比如针对于网络传输的序列参数集SPS和图像参数集PPS等。如图1所示，NAL层将SODB打包成RBSP，并且为了唯一保证起始码简化解码过程，会在RBSP尾零之后添加0x03，最后加上NAL头，就完成了一个NAL单元。 1.2.3 NAL Unit类型 进一步说，在H.264标准协议中规定了多种不同的NALU类型，其中两个极为重要的类型是SPS和PPS。 如图2所示，类型7就表示该个NALU内保存的数据为序列参数集Sequence Paramater Set(SPS),类型8表示该个NALU内保存的数据为图像参数集Picture Paramater Set(PPS)。通常情况下，PPS类似于SPS，在H.264的裸码流中单独保存在一个NAL Unit中。SPS中保存了一组编码视频序列Coded video sequence的全局参数 [8]。所谓的编码视频序列即原始视频的一帧一帧的像素数据经过编码之后的结构组成的序列，每一帧的编码后数据所依赖的参数保存于图像参数集（PPS）中[9]。SPS和PPS类型的NALU一般位于整个码流的起始位置，如果其中的数据丢失或出现错误，那么解码过程很可能会失败。 图2： NAL单元类型 参考文献 [1] Bitmovin. Video Develpler Report 2019．Video Developer Report 2019 [2]A.Nurrohman and M. Abdurohman, “High Performance Streaming Based on H264 and Real Time Messaging Protocol (RTMP),” 2018 6th International Conference on Information and Communication Technology (ICoICT), Bandung, 2018, pp. 174-177. [3] Grecos,C., Mingyuan Yang, A framework for fast mode decision in the H264 video coding standard,Digital Signal Processing, 2007,17(3):652-664. [4] 代路伟,罗家融.H．264解码器中帧内预测模块的硬件设计[J].网络新媒体技术,2016(2):30-35. [5] N.Belhadj, N. Bahri, M. Ali Ben Ayed, Z. Marrakchi and H. Mehrez, “Data level parallelism for H264/AVC baseline intra-prediction chain on MPSoC,” 10th International Multi-Conferences on Systems, Signals &amp; Devices 2013 (SSD13), Hammamet, 2013, pp. 1-4. [6]何俊,田应洪,洪志良.基于H．264的熵编码结构[J].计算机工程,2008,34(6):229-232. [7] Yumin Chan. Introduction to H.264:SODB vs RBSP vs EBSP &amp; NAL Unit. https://yumichan.net/video-processing/video-compression [8] Jungheum Park, Sangjin Lee,Data fragment forensics for embedded DVR systems Digital Investigation,Volume 11, Issue 3,2014,Pages 187-200","categories":[{"name":"音视频","slug":"音视频","permalink":"http://zdszx.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"}],"tags":[{"name":"H264","slug":"H264","permalink":"http://zdszx.github.io/tags/H264/"}]},{"title":"流媒体传输协议RTP与视频H264编码格式","slug":"hello_world","date":"2021-07-02T03:41:10.000Z","updated":"2021-07-28T12:57:39.784Z","comments":true,"path":"2021/07/02/hello_world/","link":"","permalink":"http://zdszx.github.io/2021/07/02/hello_world/","excerpt":"流媒体传输协议RTP与视频H264编码格式RTP，即real-time transport protocol（实时传输协议），为实时传输交互的音频和视频提供了端到端传输服务,应用层协议。","text":"流媒体传输协议RTP与视频H264编码格式RTP，即real-time transport protocol（实时传输协议），为实时传输交互的音频和视频提供了端到端传输服务,应用层协议。其包括载荷的类型确认，序列编码，时间戳和传输监控功能。一般应用都是基于UDP协议，来使用RTP的多路技术以及验和服务。RTP可以比较容易的拓展以传递某些特定需要的内容，而且可以比较容易地集成进某个应用，而不是作为一个独立的补充层。所以RTP协议被故意地设计成不完整的协议框架。RTP还可以与其它适合的协议并用，如果底层网络支持多路分发，RTP还可以将数据传输给多个目标。 需要注意的是RTP不提供任何机制以保证数据的实时性和QOS(quality-of-service)，而是依赖底层的服务来提供这些功能。接收端可以利用RTP中的序列号排序收到的报文。RTP payload：RTP包中传输的数据，比如音频采样数据或者压缩过的视频数据。RTP packet：由定长RTP头部，数据来源者的列表，RTP payload组成的数据包。一些下层协议可能会自己定义RTP的封装格式。一般来说，一个下层协议包只包含一个RTP包，但是也有可能多个RTP包被合并到一起。RTCP packet：RTP控制报文，由定长的RTC头部开始，之后会跟着一些结构化的元素，它们在RTCP发挥不同功能时，会有不同的结构。通常多个RTCP包会被合在一起，通过一个下层协议包一起发送。RTCP 发送者报告和接受者报告只描述了时序和序列号而不包含payload类型数据。RTP session：一组参与者利用RTP来通讯的组合。一个参与者可以同时加入到多个RTP session中。在Multimedia session中，除非特意将多媒体编码进同一数据流，否则，每个数据流会通过不同的RTP Session传输。与会者通过Transport address来区分不同的RTP session。同一RTP session的不同与会者会共享同一个Transport address，也可能每个与会者都有自己的Transport address。在单播的情况时，一个与会者可能用同一对端口（RTP&amp;RTCP）来接受所有其他与会者的数据，也可能对不同的与会者采用不同的端口对（RTP&amp;RTCP）。Synchronization source (SSRC)：RTP报文流的一个Source，由RTP头中定义的32-bit的SSRC identifier来标识，这样做是为了不依赖网络地址。同一个SSRC中发送的所有包都具有同一时序和序列号间隔，因此接收者可以通过SSRC将收到的数据包分组并排序。一个信号源（麦克风，摄像头，Mixer）的报文流会有由一个SSRC的发送器发送。一个SSRC可能会随着时间的变化，改变其数据格式，例如音频编码。SSRC的身份识别码都是随机生成的，但是必须保证整个RTP session中该身份识别码不会重复，这些工作是通过RTCP来完成的。如果一个与会者在一个RTP session中发送不同的媒体数据流，那么每个流的SSRC必须不同。一个SSRC只有一个对应的时序和序列号，如果多个流有不同的时钟周期的话，就需要不同的时序。而且还不能用序列号来确认是哪个流丢包了RTP头的格式RTCP包格式RTP控制协议同一个Session所有参与者会周期性地发送控制报文，RTP控制协议就是通过这种方式进行的，和RTP数据的传播一样采用了组播的机制。下层协议必须提供数据包和控制报文的多路复用功能，例如使用独立的UDP端口分别传输数据和控制报文。RTCP协议具有如下四大功能：\\1. 最主要的功能是反馈数据分发的质量。这也是RTP作为一个传输协议来说最关键的功能，而且它和流量控制，拥塞控制息息相关。反馈信息可能会直接影响自适应编码的控制。发送反馈报告给所有的参与者可以让它们评估遇到的数据分发问题是个人问题还是全局问题。\\2. RTCP还会给每个RTP source带一个不变的传输层身份识别符（CNAME），因为SSRC可能会中途改变（程序重启），所以接受者需要这个CNAME来持续追踪每个与会者。而且，接受者可以通过CNAME来将同一个与会者的所有数据流联系在一起，比如同步音频和视频。\\3. 因为前两个功能需要所有的与会者都发送RTCP报文，所以需要适当的控制报文发送的频率以至于RTP协议可以在大量客户端一同加入时也能正常工作。通过每个参与者都广播控制报文的方式，每个人都能独立地计算出参与者的总数怎么在TCP/UDP基础上继续魔改？从RTP看去1.RTP的设计理念是它要能根据session参与者的人数增加而进行自适应处理。例如，音频会议中同一时刻说话的一般也就那么一两个人（这就从内部限制了音频数据的传输），那么可以认为组播数据分发所用到的带宽资源和与会人数无关。控制信息的发送和音频数据的传输不同，每个人都会不停的发送RTCP报文，如果每个参与者的接受报告以同一个周期发送的话，RTCP报文传输所消耗的资源会随着与会人数的增加而线性增加。因此，当与会人数增加时，RTCP报文的发送间隔应该相应的动态地增大。 对每个session来说，会有一个总的带宽限制（Session bandwidth），它会被分配给每个独立的与会者。整个网络的带宽可能会有所保留，并从网络层面强制限制Session的带宽。2.发送间隔计算RTCP的发送间隔需要随着Session总人数的变化而适当的缩放。结合上述的部分状态，我们按如下方式计算RTCP报文间隔： 1. 如果媒体流发送者的数量小于总人数的25%时，这个间隔和当前节点是否是媒体流发送者有关（通过WE_Sent判断）。如果是媒体流发送者，计算公式为：Senders AVG_RTCP_Size / (25% RTCP_BW)，如果是媒体流的接收者，计算公式为：（Members - Senders） AVG_RTCP_Size / (75% RTCP_BW)。当媒体流发送者的数量超过25%时，发送者和接受者会被同等对待，即它们的RTCP周期公式为：Members * AVG_RTCP_Size / RTCP_BW。3.拥塞控制所有的网络传输协议都需要拥塞控制，RTP也不例外，但是因为RTP的数据传输不会发生特别大的激变（固定频率发送，控制了带宽），所以RTP的拥塞控制会和TCP这类的实现有很大差别，RTP不会像TCP那样占用所有带宽。RTP的这种数据传输模式虽然降低了拥塞的风险，但是一旦发生了拥塞，也不能莽莽地减少网络负载。 因为RTP面向的是各种各样的上层应用，没有一个拥塞控制机制能适用于所有的情况。因此，拥塞控制部分应该定义在预设中，或者上层应用中。在有些预设中，会根据RTCP的反馈来适当的调整数据传输带宽。4.保密性保密性是指我们的报文只希望一些特定的接受者可以解码成明文，而其他人只能得到无用的信息，保密性是通过加密编码来提供的。 当需要为RTP和RTCP报文提供加密服务时，所有传输的内容都会在下层报文那里进行加密。对于RTCP来说，需要一个32-bit的随机数作为前缀。而RTP报文不需要前缀，取而代之的是随机序列号和时间戳偏移。前面提到过也可以用IP级的加密方案或者RTP级的加密。一些预设可能会定义别的payload类型来加密，这种方案，可能只加密payload部分而头部分使用明文，因为只有payload部分才是应用真正需要的内容。这可能对硬件设备来说非常有用，它即处理解密过程，又处理解码过程。","categories":[{"name":"web前端","slug":"web前端","permalink":"http://zdszx.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"流媒体传输","slug":"流媒体传输","permalink":"http://zdszx.github.io/tags/%E6%B5%81%E5%AA%92%E4%BD%93%E4%BC%A0%E8%BE%93/"}]},{"title":"Boy Next Door♂","slug":"lxd","date":"2021-07-02T03:41:10.000Z","updated":"2021-07-06T12:13:56.000Z","comments":true,"path":"2021/07/02/lxd/","link":"","permalink":"http://zdszx.github.io/2021/07/02/lxd/","excerpt":"罗旭东 帅因何而发生？ 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 经过上述讨论， 洛克在不经意间这样说过，学到很多东西的诀窍，就是一下子不要学很多。这句话语虽然很短，但令我浮想联翩。 生活中，若罗旭东 帅出现了，我们就不得不考虑它出现了的事实。 孔子在不经意间这样说过，知之者不如好之者，好之者不如乐之者。这不禁令我深思。 这样看来， 经过上述讨论， 带着这些问题，我们来审视一下罗旭东 帅。 黑格尔曾经提到过，只有永远躺在泥坑里的人，才不会再掉进坑里。这似乎解答了我的疑惑。 生活中，若罗旭东 帅出现了，我们就不得不考虑它出现了的事实。 可是，即使是这样，罗旭东 帅的出现仍然代表了一定的意义。 我们都知道，只要有意义，那么就必须慎重考虑。 鲁巴金说过一句富有哲理的话，读书是在别人思想的帮助下，建立起自己的思想。我希望诸位也能好好地体会这句话。 可是，即使是这样，罗旭东 帅的出现仍然代表了一定的意义。 而这些并不是完全重要，更加重要的问题是， 一般来讲，我们都必须务必慎重的考虑考虑。 就我个人来说，罗旭东 帅对我的意义，不能不说非常重大。","text":"罗旭东 帅因何而发生？ 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 经过上述讨论， 洛克在不经意间这样说过，学到很多东西的诀窍，就是一下子不要学很多。这句话语虽然很短，但令我浮想联翩。 生活中，若罗旭东 帅出现了，我们就不得不考虑它出现了的事实。 孔子在不经意间这样说过，知之者不如好之者，好之者不如乐之者。这不禁令我深思。 这样看来， 经过上述讨论， 带着这些问题，我们来审视一下罗旭东 帅。 黑格尔曾经提到过，只有永远躺在泥坑里的人，才不会再掉进坑里。这似乎解答了我的疑惑。 生活中，若罗旭东 帅出现了，我们就不得不考虑它出现了的事实。 可是，即使是这样，罗旭东 帅的出现仍然代表了一定的意义。 我们都知道，只要有意义，那么就必须慎重考虑。 鲁巴金说过一句富有哲理的话，读书是在别人思想的帮助下，建立起自己的思想。我希望诸位也能好好地体会这句话。 可是，即使是这样，罗旭东 帅的出现仍然代表了一定的意义。 而这些并不是完全重要，更加重要的问题是， 一般来讲，我们都必须务必慎重的考虑考虑。 就我个人来说，罗旭东 帅对我的意义，不能不说非常重大。 后面的内容在首页不显示，只显示到这里","categories":[{"name":"diu","slug":"diu","permalink":"http://zdszx.github.io/categories/diu/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://zdszx.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"hexo","slug":"hexo","permalink":"http://zdszx.github.io/tags/hexo/"}]}],"categories":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://zdszx.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"python","slug":"python","permalink":"http://zdszx.github.io/categories/python/"},{"name":"音视频","slug":"音视频","permalink":"http://zdszx.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"},{"name":"web前端","slug":"web前端","permalink":"http://zdszx.github.io/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"diu","slug":"diu","permalink":"http://zdszx.github.io/categories/diu/"}],"tags":[{"name":"DX11 pipeline","slug":"DX11-pipeline","permalink":"http://zdszx.github.io/tags/DX11-pipeline/"},{"name":"python","slug":"python","permalink":"http://zdszx.github.io/tags/python/"},{"name":"H264","slug":"H264","permalink":"http://zdszx.github.io/tags/H264/"},{"name":"流媒体传输","slug":"流媒体传输","permalink":"http://zdszx.github.io/tags/%E6%B5%81%E5%AA%92%E4%BD%93%E4%BC%A0%E8%BE%93/"},{"name":"博客","slug":"博客","permalink":"http://zdszx.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"hexo","slug":"hexo","permalink":"http://zdszx.github.io/tags/hexo/"}]}